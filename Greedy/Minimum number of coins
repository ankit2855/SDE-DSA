// GFG

// So greedy approach will be to sort the array and then start from the
// last element and keep subtracting it from the sum required until it's value
// is greater than the left over sum.
// Now this technique works for coins in India having denominations
// {1,2,5,50,100,500,1000} but it doesnâ€™t work for denominations {9, 6, 5, 1} and V = 11.
// The above approach would print 9, 1 and 1. But we can use 2 denominations 5 and 6.
// TC : O(N) SC : O(1).

//#############################################################################################################################
// Another approach would be to form all the combinations of coins that equal to given sum
// and pick the one having the least number of coins. Draw a recursion tree for better understanding.
// {9,6,5,1} and V = 11 so 1st step of recursion will be minCoins(11-9),minCoins(11-6),minCoins(11-5),minCoins(11-1).
// i.e basically we take all those coins that are less than or equal to the given sum and do this step recursively until we
// get the result. The result is calculated by choosing the minimum value generated by all the child recursive calls.
// TC : exponential.

class Solution{

	public:
	int minCoins(int coins[], int M, int V) 
	{ 
	    int result = -1;
	  
    // Base case of recursion.
	    if(V == 0)return 0;
	    
	    for(int i = 0; i < M; i++){
	        
	        if(coins[i] <= V){
	            
              //recursively call for all the coins whose value
              // is less than or equal to V after subtracting them from V.
              
	            int sub_result = minCoins(coins,M,V-coins[i]);
	            
              // If the child recursive call of the current recursion
              // returned a value other than -1 to obtain the given sum at that point
              // then choose that as result.
	            if(sub_result != -1){
	                result = min(result,sub_result + 1);
	            }
	        }
	        
	    }
	
	    return result;
	}
 };
	  
    
//#####################################################################################################################################################################//

// Now the most optimal solution that works for all the cases
// is ofcourse minimizing the above TC of recursion by using what? Dynamic Programming!
// So basically we create a dp array of size  (sum+1).
// And assign dp[0] as 0 since to get a sum of 0 we need to pick 0 coins and all others as INT_MAX.
// Now for every dp[i] from i=1 to i=sum we find the value in given array which are less than
// or equal to i we write it's value i.e using how many coins can a sum of 'i' be obtained.
// At last we return dp[V] which will be the minimum coins needed to achieve the sum of V using
// the given denominations or coins in the array.

// For eg coins[] = {3, 4 ,1}. and V = 5
// dp[5+1] = [0,INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX] (INITIALLY).

// then afterwards dp[] = [0,1,2,1,1,2] for i = 0 to 5 we have these many minimum coins
// to reach a given ith sum in the range of 0 to 5. So at last we return dp[V] i.e dp[5] which is 2.
// NOTE that generating a sum can be done in a lot of ways but for each sum 'i' we make sure we choose
// the way which uses minimum coins using the condition -> dp[i] = min(dp[i],sub_result + 1);.

class Solution{

	public:
	int minCoins(int coins[], int M, int V) 
	{ 
	    int dp[V+1];
	    
	    if(V == 0)return 0;
	    
	    dp[0] = 0;

// Default value of every dp[i] except dp[0] is INT_MAX.
    for(int i = 1; i<=V; i++){
	        
	        dp[i] = INT_MAX;
	    }
      
      // Now for i = 1 to i = V we find
      // the minimum number of coins needed to obtain the sum i.
      
	    for(int i = 1; i<=V; i++){
	        
	        for(int j = 0; j<M; j++){
	    
      // Picking all the coins that are <= sum needed.
      
	        if(coins[j] <= i){
	            
	            int sub_result = dp[i-coins[j]];
	            
	            if(sub_result != INT_MAX){
	              
                // Adding 1 in subresult here since we already
                // used a coin when we did dp[i-"coins[j]"].
              
	                dp[i] = min(dp[i],sub_result + 1);
	            
	                
	            }
	        }
	   }
	        
	    }
	
	    return dp[V] == INT_MAX ? -1 : dp[V];
	} 
	  
};

















